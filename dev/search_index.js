var documenterSearchIndex = {"docs":
[{"location":"quickstart/#Quickstart-1","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"#arvizjl-1","page":"Home","title":"ArviZ.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl is a Julia interface to the ArviZ package for exploratory analysis of Bayesian models.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The reader is urged to consult ArviZ's documentation for detailed description of features and usage. This documentation will be limited to differences between the packages, applications using Julia's probabilistic programming languages (PPLs), and examples in Julia.","category":"page"},{"location":"#purpose-1","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Besides removing the need to explicitly import ArviZ with PyCall.jl, ArviZ.jl extends ArviZ with functionality for converting Julia types into ArviZ's InferenceData format. It also allows smoother usage with PyPlot.jl and Pandas.jl and provides functions that can be overloaded by other packages to enable their types to be used with ArviZ.","category":"page"},{"location":"#installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install ArviZ.jl with its Python dependencies in Julia's private conda environment, in the console run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"PYTHON=\"\" julia -e 'using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/sethaxen/ArviZ.jl\"))'","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To use with the default Python environment, first install ArviZ. Then in Julia's REPL run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add https://github.com/sethaxen/ArviZ.jl","category":"page"},{"location":"#design-1","page":"Home","title":"Design","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl supports all of ArviZ's API, except for its Numba functionality. See ArviZ's API documentation for details.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl wraps ArviZ's API functions and closely follows ArviZ's design. It also supports conversion of MCMCChains's Chains as returned by Turing.jl, CmdStan.jl, StanSample.jl, and others into ArviZ's InferenceData format. See Quickstart for examples.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The package is intended to be used with PyPlot.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl development occurs on GitHub. Issues and pull requests are welcome.","category":"page"},{"location":"#differences-1","page":"Home","title":"Differences from ArviZ","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In ArviZ, functions in the API are usually called with the package name prefix, (e.g. arviz.plot_posterior). In ArviZ.jl, most of the same functions are exported and therefore called without the prefix (e.g. plot_posterior). The exception are from_xyz converters for packages that have no (known) Julia wrappers. These functions are not exported to reduce namespace clutter.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl transparently interconverts between arviz.InferenceData and our own InferenceData, used for dispatch. InferenceData has identical usage to its Python counterpart.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Functions that in ArviZ return Pandas types here return their Pandas.jl wrappers, which are used the same way.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ includes the context managers rc_context and interactive_backend. ArviZ.jl includes functions that can be used with a nearly identical syntax. interactive_backend here is not limited to an IPython/IJulia context.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In place of arviz.style.use and arviz.style.styles, ArviZ.jl provides ArviZ.use_style and ArviZ.styles.","category":"page"},{"location":"#knownissues-1","page":"Home","title":"Known Issues","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl uses PyCall.jl to wrap ArviZ. At the moment, Julia segfaults if Numba is imported, which ArviZ does if it is available. For the moment, the workaround is to specify a Python version that doesn't have Numba installed. See this issue for more details.","category":"page"}]
}
